-- Migration: Strict Branch Inventory Management
-- 1. Create branch_stock table (if it doesn't likely exist properly or to ensure structure)
-- We assume 'products' table manages global details, but 'branch_stock' manages physical inventory per branch.

CREATE TABLE IF NOT EXISTS public.branch_stock (
    id bigint generated by default as identity primary key,
    branch_id bigint references public.branches(id) on delete cascade not null,
    product_id bigint references public.products(id) on delete cascade not null,
    quantity integer default 0 not null,
    min_quantity integer default 0, -- Safety stock level
    created_at timestamp with time zone default timezone('utc'::text, now()) not null,
    updated_at timestamp with time zone default timezone('utc'::text, now()) not null,
    unique(branch_id, product_id)
);

-- 2. RLS for Stock
ALTER TABLE public.branch_stock ENABLE ROW LEVEL SECURITY;

-- Policy: Users can see stock of their own branch (or all if admin)
CREATE POLICY "View Branch Stock" ON public.branch_stock
FOR SELECT USING (
  auth.uid() IN (
    SELECT id FROM auth.users WHERE get_user_branch_id() IS NULL OR get_user_branch_id() = branch_stock.branch_id
  )
);

-- Policy: Only Admins can manually adjust stock directly (Managers might use Transfers)
CREATE POLICY "Admin Manage Stock" ON public.branch_stock
FOR ALL USING (
  auth.uid() IN (SELECT id FROM auth.users WHERE get_user_branch_id() IS NULL)
);


-- 3. Trigger: Deduct Stock on Sale (Strictly from Sale Branch)
CREATE OR REPLACE FUNCTION handle_sale_stock_deduction()
RETURNS TRIGGER
LANGUAGE plpgsql
SECURITY DEFINER
AS $$
DECLARE
    v_branch_id bigint;
    v_current_stock int;
BEGIN
    -- Get Branch ID from the parent Sale
    SELECT branch_id INTO v_branch_id FROM public.sales WHERE id = NEW.sale_id;

    -- If no branch assigned (Admin sale with no branch selected?), assume main or error? 
    -- Application Logic enforces branch_id is set. If NULL (global sale), we might skip or deduct from 'Main'?
    -- Let's assume strict: Must have branch_id.
    
    IF v_branch_id IS NOT NULL THEN
        -- Check if stock record exists
        SELECT quantity INTO v_current_stock 
        FROM public.branch_stock 
        WHERE branch_id = v_branch_id AND product_id = NEW.product_id;

        IF NOT FOUND THEN
            -- Functionally: Treat as 0 stock.
            RAISE EXCEPTION 'Product % not initialized in Branch % inventory.', NEW.product_id, v_branch_id;
        END IF;

        IF v_current_stock < NEW.quantity THEN
            RAISE EXCEPTION 'Insufficient stock in Branch %. Available: %, Requested: %', v_branch_id, v_current_stock, NEW.quantity;
        END IF;

        -- Deduct
        UPDATE public.branch_stock
        SET quantity = quantity - NEW.quantity,
            updated_at = now()
        WHERE branch_id = v_branch_id AND product_id = NEW.product_id;
    END IF;

    RETURN NEW;
END;
$$;

-- Drop existing trigger if conflict (unlikely new name)
DROP TRIGGER IF EXISTS tr_deduct_stock ON public.sale_items;

CREATE TRIGGER tr_deduct_stock
AFTER INSERT ON public.sale_items
FOR EACH ROW
EXECUTE FUNCTION handle_sale_stock_deduction();


-- 4. Trigger: Cancel/Delete Sale -> Restore Stock
CREATE OR REPLACE FUNCTION handle_sale_stock_restoration()
RETURNS TRIGGER
LANGUAGE plpgsql
SECURITY DEFINER
AS $$
DECLARE
    v_branch_id bigint;
BEGIN
    -- Get Branch ID from OLD Sale (for delete sale_items) 
    -- Note: If we delete SALE, sale_items cascade delete. We need to handle that.
    -- Better to handle on BEFORE DELETE of sale_items? 
    -- Or relies on finding the sale before it's gone.
    
    SELECT branch_id INTO v_branch_id FROM public.sales WHERE id = OLD.sale_id;
    
    IF v_branch_id IS NOT NULL THEN
         UPDATE public.branch_stock
        SET quantity = quantity + OLD.quantity,
            updated_at = now()
        WHERE branch_id = v_branch_id AND product_id = OLD.product_id;
    END IF;
    
    RETURN OLD;
END;
$$;

DROP TRIGGER IF EXISTS tr_restore_stock ON public.sale_items;

CREATE TRIGGER tr_restore_stock
AFTER DELETE ON public.sale_items
FOR EACH ROW
EXECUTE FUNCTION handle_sale_stock_restoration();

-- 5. Helper Function for Frontend to check stock quickly
CREATE OR REPLACE FUNCTION get_branch_stock_level(p_branch_id bigint, p_product_id bigint)
RETURNS integer
LANGUAGE sql
STABLE
AS $$
  SELECT COALESCE(
    (SELECT quantity FROM public.branch_stock WHERE branch_id = p_branch_id AND product_id = p_product_id), 
    0
  );
$$;
